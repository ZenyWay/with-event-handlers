!function(){return function e(t,n,r){function o(i,c){if(!n[i]){if(!t[i]){var s="function"==typeof require&&require;if(!c&&s)return s(i,!0);if(a)return a(i,!0);var u=new Error("Cannot find module '"+i+"'");throw u.code="MODULE_NOT_FOUND",u}var l=n[i]={exports:{}};t[i][0].call(l.exports,function(e){var n=t[i][1][e];return o(n||e)},l,l.exports,e,t,n,r)}return n[i].exports}for(var a="function"==typeof require&&require,i=0;i<r.length;i++)o(r[i]);return o}}()({1:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});class r{constructor(e,t,n){this.dispatch=e,this.action=t,this.parent=n,this.handle=((...e)=>{this.dispatch(this.action.apply(void 0,e));const{parent:t}=this;if(!t)return;const n=e[e.length-1];o(t)?function(e,t){e.event(e.data,t)}(t,n):t(n)})}withParent(e){return function(e,t){return!e&&!t||e===t||function(e,t){return!!t&&o(e)&&e.event===t.event&&e.data===t.data}(e,t)}(this.parent,e)?this:new r(this.dispatch,this.action,e)}}function o(e){return!!e&&"data"in e&&function(e){return"function"==typeof e}(e.event)}n.default=r},{}],2:[function(e,t,n){"use strict";var r=this&&this.__rest||function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)t.indexOf(r[o])<0&&(n[r[o]]=e[r[o]])}return n};Object.defineProperty(n,"__esModule",{value:!0});const o=e(1);n.default=function(e){if(!e||!e.onProps)throw new Error("missing or invalid IndexedMap of action creators");return function(t){const n=function(e,t){return Object.keys(t).reduce(function(n,r){const a=t[r];return n[r]=new o.default(e,a),n},{})}(t,e),{onProps:a}=n,i=r(n,["onProps"]),c=Object.keys(i);return function(e){a.handle(function(e){const t=Object.assign({},e);let n=c.length;for(;n--;){const r=c[n],o=i[r].withParent(e[r]);i[r]=o,t[r]=o.handle}return t}(e))}}}},{1:1}],3:[function(e,t,n){"use strict";const r=e(2).default;describe("createPropsHandler:",function(){describe("when called with an IndexedMap of action creators, that includes an `onProps` key:",function(){let e;beforeEach(function(){e=r({onProps:function(){}})}),it("returns a props handler factory",function(){expect(e).toEqual(jasmine.any(Function))}),describe("the returned props handler factory:",function(){describe("when called with a dispatcher (val: any) => void:",function(){let e,t,n,o,a,i,c,s;beforeEach(function(){n=jasmine.createSpy("dispatch"),i=jasmine.createSpy("onProps").and.returnValue({type:"PROPS"}),c=jasmine.createSpy("onEvent").and.returnValue({type:"EVENT"}),s=jasmine.createSpy("onEvent").and.returnValue({type:"LINKEVENT"}),t=r(e={onEvent:c,onLinkEvent:s,onProps:i}),o=t(n),a=o({foo:"foo"})}),it("returns a handler function",function(){expect(o).toEqual(jasmine.any(Function)),expect(a).toBeUndefined()}),describe("the returned props handler:",function(){it("calls the `onProps` action creator with a copy of the given props extended with handlers from the remaining action creators",function(){expect(i).toHaveBeenCalledWith({foo:"foo",onEvent:jasmine.any(Function),onLinkEvent:jasmine.any(Function)})}),it("calls the dispatcher with the output from the `onProps` action creator",function(){expect(n).toHaveBeenCalledWith({type:"PROPS"})})}),describe("the handlers added to the given props:",function(){beforeEach(function(){n.calls.reset(),c.calls.reset(),s.calls.reset();const e=i.calls.argsFor(0)[0];e.onEvent({bar:"bar"}),e.onLinkEvent("context",{baz:"baz"})}),it("call the corresponding action creator with its arguments ",function(){expect(c).toHaveBeenCalledWith({bar:"bar"}),expect(s).toHaveBeenCalledWith("context",{baz:"baz"})}),it("call the dispatcher with the output from the corresponding action creator",function(){expect(n.calls.allArgs()).toEqual([[{type:"EVENT"}],[{type:"LINKEVENT"}]])})}),describe("when the given props already include some handlers sharing the same keys as some of the remaining action creators",function(){let e;beforeEach(function(){n.calls.reset(),i.calls.reset(),c.calls.reset(),s.calls.reset(),e=jasmine.createSpy("parent"),o({foo:"foo",onEvent:e}),i.calls.argsFor(0)[0].onEvent({baz:"baz"}),o({bar:"bar",onEvent:{data:"inferno",event:e}}),i.calls.argsFor(1)[0].onEvent({bzb:"bzb"})}),it("the conflicting handlers call the original handler when called, even if the latter is an Inferno LinkEvent object",function(){expect(e.calls.allArgs()).toEqual([[{baz:"baz"}],["inferno",{bzb:"bzb"}]])})})})})}),describe("when called with an IndexedMap of action creators, without an `onProps` key:",function(){let e;beforeEach(function(){e=function(){r({onEvent:function(){}})}}),it("returns a props handler factory",function(){expect(e).toThrow(jasmine.any(Error))})})})},{2:2}]},{},[3]);
